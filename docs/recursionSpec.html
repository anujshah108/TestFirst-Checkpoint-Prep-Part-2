<!DOCTYPE html>

<html>
<head>
  <title>recursionSpec.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>recursionSpec.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Given some number, n, factorial should
compute n <em> (n-1) </em> (n-2) … * 1
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'factorial'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The iterative approach is probably the one you
are more familiar with—it involves looping.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'iterative approach'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    it(<span class="hljs-string">'correctly computes factorial'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> result = factorialIterative(<span class="hljs-number">10</span>),
        expected = <span class="hljs-number">3628800</span>;
      expect(result).toEqual(expected);
    });
    it(<span class="hljs-string">'never calls itself'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      spyOn(<span class="hljs-built_in">window</span>, <span class="hljs-string">'factorialIterative'</span>);
      factorialIterative(<span class="hljs-number">5</span>);
      expect(factorialIterative.calls.count()).toEqual(<span class="hljs-number">1</span>);
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A recursive function handles some base case and
otherwise calls itself with different arguments.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'recursive approach'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    it(<span class="hljs-string">'handles the base case'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      expect(factorial(<span class="hljs-number">0</span>)).toEqual(<span class="hljs-number">1</span>);
    });
    it(<span class="hljs-string">'correctly comptues factorial'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      expect(factorial(<span class="hljs-number">10</span>)).toEqual(<span class="hljs-number">3628800</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>This is where we check that you’ve actually
created a recursive function.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'calls itself n + 1 times'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      spyOn(<span class="hljs-built_in">window</span>, <span class="hljs-string">'factorial'</span>).and.callThrough();
      <span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span>;
      factorial(n);
      expect(factorial.calls.count()).toEqual(n + <span class="hljs-number">1</span>);
    });
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>In the fibonacci sequence, the first and second
numbers are both equal to 1.</p>
<p>Each following number is the sum of the previous two. 
For example, this means the third number should be 2.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'recursive fibonacci'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  it(<span class="hljs-string">'handles the base cases'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Remember, to programmers the first element of an 
array is at index 0, the second at index 1, etc.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    expect(fib(<span class="hljs-number">0</span>)).toEqual(<span class="hljs-number">1</span>);
    expect(fib(<span class="hljs-number">1</span>)).toEqual(<span class="hljs-number">1</span>);
  });
  it(<span class="hljs-string">'correctly computes the third fibonacci number'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    expect(fib(<span class="hljs-number">2</span>)).toEqual(<span class="hljs-number">2</span>);
  });
  it(<span class="hljs-string">'calls itself'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    spyOn(<span class="hljs-built_in">window</span>, <span class="hljs-string">'fib'</span>).and.callThrough();
    fib(<span class="hljs-number">2</span>)
    expect(fib.calls.count()).toBeGreaterThan(<span class="hljs-number">1</span>);
  });
  it(<span class="hljs-string">'correctly computes the 23rd fibonacci number'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    expect(fib(<span class="hljs-number">22</span>)).toEqual(<span class="hljs-number">28657</span>);
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The following should pass if you’ve implemented your
recursive solution properly.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'calls itself fib(n)*2-1 times'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    spyOn(<span class="hljs-built_in">window</span>, <span class="hljs-string">'fib'</span>).and.callThrough();
    <span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">var</span> fibN = fib(n);
    expect(fib.calls.count()).toEqual(fibN * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);
  });
});

<span class="hljs-keyword">var</span> und = <span class="hljs-literal">undefined</span>,
  nll = <span class="hljs-literal">null</span>,
  bool = <span class="hljs-literal">true</span>,
  num = <span class="hljs-number">123</span>,
  str = <span class="hljs-string">"abc"</span>,
  fnc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{},
  arr = [],
  obj = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The ‘type’ function will behave a lot like JavaScript’s 
typeof operator. See more here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof</a></p>
<p>But don’t use typeof in your solution!
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'type'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  it(<span class="hljs-string">'returns the correct type of its input'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    expect(type(und)).toEqual(<span class="hljs-string">'Undefined'</span>);
    expect(type(nll)).toEqual(<span class="hljs-string">'Null'</span>);
    expect(type(bool)).toEqual(<span class="hljs-string">'Boolean'</span>);
    expect(type(num)).toEqual(<span class="hljs-string">'Number'</span>);
    expect(type(str)).toEqual(<span class="hljs-string">'String'</span>);
    expect(type(fnc)).toEqual(<span class="hljs-string">'Function'</span>);
    expect(type(arr)).toEqual(<span class="hljs-string">'Array'</span>);
    expect(type(obj)).toEqual(<span class="hljs-string">'Object'</span>);

  });
  it(<span class="hljs-string">'does not use typeof'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>this assertion looks for “typeof” anywhere in type function’s body,
but it’ll exclude comments from the search</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> commentsRemoved = type.toString()
      .replace(<span class="hljs-regexp">/\/\/[\s\S]*?\n/g</span>, <span class="hljs-string">''</span>)
      .replace(<span class="hljs-regexp">/\/\*[\s\S]*?\*\//g</span>, <span class="hljs-string">''</span>);
    <span class="hljs-keyword">var</span> bodyContainsTypeOf = <span class="hljs-regexp">/typeof/</span>.test(commentsRemoved);
    expect(bodyContainsTypeOf).toBe(<span class="hljs-literal">false</span>);
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Hmmm…if you can’t use typeof what can you do?</p>
<p>Well, go to a JS console and call .toString() on some object.
You should get something like “[object Object]”. Neat, maybe
we can get the type from this?</p>
<p>But, wait, if you .toString() an Array, or a Number, something 
different happens. We’d really like to use Object’s toString
method on some input.</p>
<p>Look into the .call method that every function has, and see
if you can figure out a way to make this happen. See the 
docs here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call</a>
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'invokes "Object\'s" toString method'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    spyOn(<span class="hljs-built_in">Object</span>.prototype.toString, <span class="hljs-string">'call'</span>).and.callThrough();
    type();
    expect(<span class="hljs-built_in">Object</span>.prototype.toString.call).toHaveBeenCalled();
  });
});</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Stringify should convert anything into a string.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>describe(<span class="hljs-string">'stringify'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>We’ll need different approaches for different types of
data, so it only makes sense that we’ll use our very own
type function on stringify’s input.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'invokes our custom "type" function'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    spyOn(<span class="hljs-built_in">window</span>, <span class="hljs-string">'type'</span>);
    stringify(<span class="hljs-literal">null</span>);
    expect(type).toHaveBeenCalled();
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Things that aren’t Arrays and Objects we’ll simply cast
into strings.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  it(<span class="hljs-string">'handles everything but Arrays and Objects'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    expect(stringify(und)).toEqual(<span class="hljs-string">'undefined'</span>);
    expect(stringify(nll)).toEqual(<span class="hljs-string">'null'</span>);
    expect(stringify(bool)).toEqual(<span class="hljs-string">'true'</span>);
    expect(stringify(num)).toEqual(<span class="hljs-string">'123'</span>);
    expect(stringify(str)).toEqual(<span class="hljs-string">'"abc"'</span>);
    expect(stringify(fnc)).toEqual(<span class="hljs-string">'function () {}'</span>);
  });
  describe(<span class="hljs-string">'on Arrays'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      spyOn(<span class="hljs-built_in">window</span>, <span class="hljs-string">'stringify'</span>).and.callThrough();
    });
    it(<span class="hljs-string">'invokes itself on each element'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> testArr = [<span class="hljs-number">1</span>, <span class="hljs-string">'something'</span>, []];
      stringify(testArr);
      expect(stringify.calls.count()).toEqual(testArr.length + <span class="hljs-number">1</span>); <span class="hljs-comment">// + 1 because of the array itself</span>
    });
    it(<span class="hljs-string">'can handle nesting'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> testArr = [<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, [<span class="hljs-literal">true</span>, <span class="hljs-string">'b'</span>, [<span class="hljs-literal">null</span>], <span class="hljs-string">'c'</span>], <span class="hljs-number">3</span>];
      stringify(testArr);</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>we expect it to be called 10 times because there
are 3 arrays with (all combined) 7 elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      expect(stringify.calls.count()).toEqual(<span class="hljs-number">10</span>);
    });
    it(<span class="hljs-string">'wraps with brackets and concatenates with commas'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> result = stringify([<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, [<span class="hljs-literal">true</span>, <span class="hljs-string">'b'</span>, [<span class="hljs-literal">null</span>], <span class="hljs-string">'c'</span>], <span class="hljs-number">3</span>]),
        expected = <span class="hljs-string">'[1,"a",[true,"b",[null],"c"],3]'</span>;
      expect(result).toEqual(expected);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The native Array.prototype.toString method actually does
exactly what we want. But we’d like you to figure it out
yourself.</p>
<p>You might find Array.prototype.join useful.
/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'does not use native string conversion'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      spyOn(<span class="hljs-built_in">Array</span>.prototype, <span class="hljs-string">'toString'</span>);
      stringify([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
      expect(<span class="hljs-built_in">Array</span>.prototype.toString).not.toHaveBeenCalled();
    });
  });
  describe(<span class="hljs-string">'on Objects'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    it(<span class="hljs-string">'invokes itself on each value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> testObj = {
        a: <span class="hljs-number">1</span>,
        b: <span class="hljs-number">2</span>
      };
      spyOn(<span class="hljs-built_in">window</span>, <span class="hljs-string">'stringify'</span>).and.callThrough();
      stringify(testObj);
      expect(stringify.calls.count()).toEqual(<span class="hljs-built_in">Object</span>.keys(testObj).length + <span class="hljs-number">1</span>);
    });
    it(<span class="hljs-string">'wraps with curly braces, inserts colons, and concatenates with commas'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> result = stringify({
          a: <span class="hljs-number">1</span>,
          b: <span class="hljs-number">2</span>
        }),
        expected = <span class="hljs-string">'{"a": 1,"b": 2}'</span>;
      expect(result).toEqual(expected);
    });
    it(<span class="hljs-string">'can handle arbitrary nesting'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> result = stringify({
          a: {
            b: <span class="hljs-literal">true</span>,
            c: [<span class="hljs-literal">null</span>, {
              d: <span class="hljs-number">1</span>
            }],
            e: {
              f: <span class="hljs-string">"abc"</span>
            }
          },
          g: <span class="hljs-literal">undefined</span>
        }),
        expected = <span class="hljs-string">'{"a": {"b": true,"c": [null,{"d": 1}],"e": {"f": "abc"}},"g": undefined}'</span>;
      expect(result).toEqual(expected);
    });
  });
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
